#!/usr/bin/env bash

# Uso: ./jshell-resolve com.google.guava:guava:33.5.0-jre ...

[ $# -eq 0 ] && {
  echo "Usage: jshell-resolve [group:artifact:version]+" >&2
  echo "Example: jshell-resolve com.google.guava:guava:33.5.0-jre" >&2
  exit 1
}

# Construye las dependencias (cada línea: implementation 'group:artifact:version')
DEPENDENCIES=$(for dep in "$@"; do
  printf "  implementation '%s'\n" "$dep"
done)

WORKDIR="$(pwd)"

# Comando que se ejecuta dentro del contenedor
CMD=$(cat <<'END_OF_CMD'
set -euo pipefail

# 1) Cabecera del build.gradle (Groovy DSL moderno, Java 25 toolchain, sin jcenter)
cat > build.gradle <<'END_OF_BUILD_HEAD'
plugins {
  id 'java'
}

repositories {
  mavenCentral()
}

dependencies {
END_OF_BUILD_HEAD

# 2) Inyecta dependencias desde variable de entorno (si está vacía, no falla)
#    Usamos ${DEPENDENCIES:-} para evitar "unbound variable" con set -u
printf "%s\n" "${DEPENDENCIES:-}" >> build.gradle

# 3) Cierre del bloque y tarea moderna para escribir el CLASSPATH
cat >> build.gradle <<'END_OF_BUILD_TAIL'
}

tasks.register('printClasspath') {
  doLast {
    def cp = configurations.runtimeClasspath.asPath
    file('classpath').text = 'export CLASSPATH="' + cp + '"'
  }
}
END_OF_BUILD_TAIL

# Ejecuta y abre jshell con el CLASSPATH resuelto
gradle -q printClasspath
source classpath
exec jshell
END_OF_CMD
)

# Ejecuta Docker pasando DEPENDENCIES como variable de entorno
docker run -it --rm \
  -u gradle \
  -w /home/gradle/project \
  -v "$WORKDIR":/home/gradle/project \
  -e "DEPENDENCIES=$DEPENDENCIES" \
  gradle:jdk25-noble \
  /bin/bash -c "$CMD"
